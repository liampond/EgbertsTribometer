import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.lines import Line2D
from matplotlib.colors import LinearSegmentedColormap, ListedColormap
import numpy as np
import os
import re
from ast import literal_eval

# Import data from files in ParsedFiles folder. Data parsed and generated by parse_tribometer.py
master = pd.read_csv('ParsedFiles/Master.csv', converters={"Avg_Friction": literal_eval})
valid_master = pd.read_csv('ParsedFiles/ValidMaster.csv', converters={"Avg_Friction": literal_eval})

# TODO Rename first column to 'index'

# Plot all files?
plot_all = False

# Plot all tests separately by OA concentration? (unaveraged)
plot_by_oa = False

# Average all tests of a given combination of OA and force?
average_all_tests = True

# Plot files individually? Which ones?
# plot_test_list = ['TribometerLogs/Sample 9 OA-1 - Feb 19/PAO4+OA-1_20N_20mms_test3_Feb19',
#                  'TribometerLogs/Sample 9 OA-1 - Feb 19/PAO4+OA-1_20N_20mms_test4_Feb19',
#                  'TribometerLogs/Sample 9 OA-1 - Feb 19/PAO4+OA-1_20N_100mms_test6_Feb19']

# Define a dictionary to store the DataFrame subsets
oa_groups = {}

oa_conc_values = [0, 1, 10, 20]
force_values = [10, 20]

# Iterate through each combination of OAConc and Force values
for oa_conc in oa_conc_values:
    for force in force_values:
        key = f"oa{oa_conc}_force{force}"
        # Store the subset in the dictionary with the appropriate key
        oa_groups[key] = valid_master.loc[
            (valid_master['OAConc'] == oa_conc) & (valid_master['Force'] == force)
            ]

# TODO IMPLEMENT

test_averages = oa_groups


def friction_avg(friction_column: pd.Series):
    """
    Calculate the average friction given many series
    Computes the average index-wise
    :param friction_column: A column of a dataframe containing the friction series data
    :return param_avg_friction: A series containing the averaged values in each index
    """

    param_avg_friction = np.mean([friction_column.iloc[i] for i in range(len(friction_column))], axis=0)

    # OLD VERSION THAT USES *ARGS WITH EACH SERIES AS AN INPUT INSTEAD OF TAKING AN ENTIRE DATAFRAME

    # zipped_column = [zip(friction_column.iloc[i]) for i in range(len(friction_column))]
    #
    # # Calculate the sum of values at each index across all lists
    # sums = [sum(x) for x in zipped_column]
    #
    # # Calculate the average for each index
    # param_avg_friction = [x / len(zipped_column) for x in sums]

    return param_avg_friction


# Find average friction across tests for a given combination of OA/force parameters
for key, value in test_averages.items():

    one_param_data = test_averages[key]

    # For each dataframe in test_averages:
    for test_index in range(len(one_param_data)):

        # For friction series with a length less than the others, append the last element so all lists are equal length
        # for averaging
        max_cycles = one_param_data['Cycles'].max()
        # Just the series that contains the average friction
        friction_data = one_param_data.iloc[test_index]['Avg_Friction']
        # Add the last element until the list is sufficiently long
        while len(friction_data) < max_cycles:
            friction_data.append(friction_data[-1])

    # Set the Avg_Friction value in the first row to the average friction across all rows

    # Find the average across all tests for a given combination of parameters
    friction_column = one_param_data['Avg_Friction']
    test_avg_friction = friction_avg(one_param_data['Avg_Friction'])


# ----------------------------------
# PLOTTING FRICTION COEFFICIENT DATA
# ----------------------------------

def rolling_avg_plotter(friction_test: pd.DataFrame):
    """
    Plots the estimated friction coefficient graph for a test using a rolling average
    Saves the plot as a .png file
    :param friction_test: The tests to be analyzed
    :return: None
    """

    # Calculate the moving average
    window_size = 500

    # Plot rolling values against indices
    plt.plot(friction_test['Tx'].index,
             friction_test['Tx'].rolling(window=window_size).mean(),
             label=f'Moving Average (Window={window_size})',
             linestyle='--')

    plt.ylim(0, 0.2)
    plt.title('Estimated Friction Coefficient - Moving Average (500)')
    plt.xlabel('Count')
    plt.ylabel('Estimated Friction Coefficient')
    plt.legend()

    plot_folder_name = 'Friction Coefficient Graphs/'
    subfolder_name = 'OA_' + str(friction_test['OAConc']) + '/'
    # TODO Create subfolders if they don't already exist

    plot_name = plot_folder_name + \
                subfolder_name + \
                'PAO4+OA-' + \
                str(friction_test['OAConc']) + '%OA_' + \
                str(friction_test['Force']) + 'N_' + \
                str(friction_test['Speed']) + 'mms_Test' + \
                str(friction_test['TestNo']) + '_' + \
                str(friction_test['Date'])
    plt.savefig(plot_name + '.png', dpi=1000)
    plt.clf()

    return None


def cycle_avg_plotter(friction_dataframe: pd.DataFrame):
    """
    Plots the estimated friction coefficient graph for a test after averaging all values for each semi-cycle
    Saves the plot as a .png file
    :param friction_dataframe: The test to be analyzed
    :return: None
    """

    # Specifying colors for different plots
    color_set = np.linspace(0, 1, 10)
    color_index = 0
    viridis = mpl.colormaps['viridis']

    for index, test in enumerate(friction_dataframe.iloc()):
        print("Plotting test no.  ", index + 1)

        # averaged_test = cycle_avg(test)
        index_list = [i for i in range(len(test['Avg_Friction']))]

        # Setting colour logic
        # Low speed is purple, high speed is green. Subsequent tests with the same parameters get higher in the colormap
        # (ie. low speed purples look more blue, high speed greens look more yellow)
        low_count = 0
        high_count = 0
        if test['Speed'] == 20:
            base_color = 0.1
            low_count += 1
        elif test['Speed'] == 100:
            base_color = 0.6
            high_count += 1
        color = base_color + 0.2 * high_count

        # Add legends to this list — this is because the graph itself requires a very thin line with a low alpha
        # but it won't show up in the legend unless the legend parameters are different
        # legend_lines = []

        plt.plot(index_list,
                 test['Avg_Friction'],
                 linestyle='--',
                 linewidth=0.6,
                 color=viridis(color),
                 alpha=0.5,
                 label=str(test['Speed']) + 'mm/s, ' + str(test['Force']) + 'N, Test No. ' + str(index + 1))
        color_index += 1
        # legend_lines.append(Line2D([0, 1], [0, 1], linestyle='-', color=viridis(color)))

    # Make sure OA concentrations and force are the same for every test
    test_oa_conc = friction_dataframe['OAConc']
    if not all(x == test_oa_conc.iloc[0] for x in test_oa_conc):
        print('OA concentrations are not the same for each test to be plotted')

    test_force = friction_dataframe['Force']
    if not all(x == test_force.iloc[0] for x in test_force):
        print('Forces are not the same for each test to be plotted')

    plt.ylim(0, 0.2)
    plt.title('Estimated Friction Coefficient Averaged \n Per Cycle for ' +
              str(test_oa_conc.iloc[0]) + '% OA and ' +
              str(test_force.iloc[0]) + 'N')
    # TODO Smart titles
    plt.xlabel('Cycle Number')
    plt.ylabel('Average Estimated Friction Coefficient')
    plt.legend(fontsize=6)
    plt.viridis()
    # TODO legend

    plot_folder_name = 'Friction Coefficient Graphs/'
    # subfolder_name = 'OA_' + str(test_oa_conc.iloc[0]) + '/'
    # TODO Create subfolders if they don't already exist

    # TODO Eliminate TestNo and Date if friction_dataframe has only one row

    plot_name = plot_folder_name + \
                'PAO4+OA' + \
                str(friction_dataframe['OAConc'].iloc[0]) + '_' + \
                str(friction_dataframe['Force'].iloc[0]) + 'N'
    # str(friction_dataframe['Force'].iloc[0]) + 'N_' + \
    # str(friction_dataframe['Speed'].iloc[0]) + 'mms_Test' + \
    # str(friction_dataframe['TestNo'].iloc[0]) + '_' + \
    # str(friction_dataframe['Date'].iloc[0])
    plt.savefig(plot_name + '.png', dpi=1000)
    plt.clf()


def cycle_avg_plotter_by_oa(friction_dataframe: pd.DataFrame):
    """
    Plots the estimated friction coefficient graph for all tests for a given combination of OA and force
    (split by speed). Values are averaged for each semi-cycle and averaged across tests.
    Saves the plot as a .png file
    :param friction_dataframe: The tests to be analyzed
    :return: None
    """

    # Specifying colors for different plots
    color_set = np.linspace(0, 1, 10)
    tab10 = mpl.colormaps['tab10']

    for index, test in enumerate(friction_dataframe.iloc()):
        print("Plotting test no.  ", index + 1)

        # averaged_test = cycle_avg(test)
        index_list = [i for i in range(len(test['Avg_Friction']))]

        # Setting colour logic
        color = color_set[index]

        # Add legends to this list — this is because the graph itself requires a very thin line with a low alpha
        # but it won't show up in the legend unless the legend parameters are different
        # legend_lines = []

        plt.plot(index_list,
                 test['Avg_Friction'],
                 linestyle='-',
                 linewidth=0.8,
                 color=tab10(color),
                 alpha=0.5,
                 label=str(test['OAConc']) + '% OA, ' + str(test['Force']) + 'N')

    test_speed = friction_dataframe['Speed']
    if not all(x == test_speed.iloc[0] for x in test_speed):
        print('Test speeds are not the same for each test to be plotted')

    plt.ylim(0, 0.2)
    plt.title('Estimated Friction Coefficient Averaged \n Per Cycle for ' +
              str(test_speed.iloc[0]) + 'mm/s')
    # TODO Smart titles
    plt.xlabel('Cycle Number')
    plt.ylabel('Average Estimated Friction Coefficient')
    plt.legend(fontsize=6)
    plt.viridis()
    # TODO legend

    plot_folder_name = 'Friction Coefficient Graphs/'
    # subfolder_name = 'OA_' + str(test_oa_conc.iloc[0]) + '/'
    # TODO Create subfolders if they don't already exist

    # TODO Eliminate TestNo and Date if friction_dataframe has only one row

    plot_name = plot_folder_name + \
                'AveragedByOAandForce_' + \
                str(friction_dataframe['Speed'].iloc[0]) + 'mms'

    plt.savefig(plot_name + '.png', dpi=1000)
    plt.clf()


if plot_all:
    for i in range(len(master)):
        test = master.loc[i]
        if test['Validity']:
            cycle_avg_plotter(test)

elif plot_by_oa:
    for oa_dataset in oa_groups.values():
        cycle_avg_plotter(oa_dataset)
        # TODO BUGGED

elif average_all_tests:

    # ---------------
    # ORGANIZING DATA
    # ---------------

    # Create the dictionary of averaged tests by each combination of OA/force, split by speed
    avg_groups = {}

    speed_values = [20, 100]

    for speed in speed_values:
        key = f"speed{speed}"
        # Store the subset in the dictionary with the appropriate key
        avg_groups[key] = []
        for oa_key in oa_groups.keys():
            param = oa_groups[oa_key]

            # Calculate the average friction across tests for a given combination of parameters
            param_avg_friction = friction_avg(
                param.loc[(param["Speed"] == speed)]["Avg_Friction"]
            )

            # Append avg_groups[key] with the first row of param for a given speed
            avg_groups[key].append(
                param.loc[(param['Speed'] == speed)]
                .iloc[0]
                .drop(["SampleNo", "TestNo", "Date", "Filename"])
                .replace({'Avg_Friction': param_avg_friction}))

        avg_groups[key] = pd.DataFrame(avg_groups[key])

    # --------
    # PLOTTING
    # --------

    for avg_group in avg_groups.values():
        cycle_avg_plotter_by_oa(avg_group)

# else:
#    for plot_test in plot_test_list:
#        # Set test to be the filename associated with plot_test
#        test = master.loc[master['Filename'] == plot_test].iloc[0, :]
#        cycle_avg_plotter(test)

# TODO Runtime

# TODO IMPORT LOGGING
# ENABLE FULL TRACEBACK WHAT IS GOING ON??
